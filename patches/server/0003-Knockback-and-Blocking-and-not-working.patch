From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Alexandra-Myers <bia416cat@gmail.com>
Date: Fri, 22 Nov 2024 18:11:32 -0500
Subject: [PATCH] Knockback and Blocking and not working


diff --git a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
index 790e3167cfa2511ef2fc707d9b9aa681a78d8ba0..bb18d7772099ace0cbb35b8a792e0107f13e2b0f 100644
--- a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
@@ -564,7 +564,7 @@ public class WorldConfiguration extends ConfigurationPart {
         public boolean disableEndCredits = false;
         public DoubleOr.Default maxLeashDistance = DoubleOr.Default.USE_DEFAULT;
         public boolean disableSprintInterruptionOnAttack = false;
-        public int shieldBlockingDelay = 5;
+        public int shieldBlockingDelay = 0;
         public boolean disableRelativeProjectileVelocity = false;
 
         public enum RedstoneImplementation {
diff --git a/src/main/java/net/atlas/combatify/Combatify.java b/src/main/java/net/atlas/combatify/Combatify.java
new file mode 100644
index 0000000000000000000000000000000000000000..ccfb03fd2a1882c31a0de339ec4fda3f42122030
--- /dev/null
+++ b/src/main/java/net/atlas/combatify/Combatify.java
@@ -0,0 +1,32 @@
+package net.atlas.combatify;
+
+import net.atlas.combatify.util.BlockingType;
+import net.minecraft.world.item.WeaponType;
+import net.minecraft.world.item.blocking.*;
+
+import java.util.HashMap;
+import java.util.Map;
+
+@SuppressWarnings("unused")
+public class Combatify {
+	public static final String MOD_ID = "combatify";
+	public static boolean isCTS = false;
+	public static final Map<String, WeaponType> defaultWeaponTypes = new HashMap<>();
+	public static final Map<String, BlockingType> defaultTypes = new HashMap<>();
+	public static final BlockingType SHIELD = defineDefaultBlockingType(new ShieldBlockingType("shield"));
+	public static final BlockingType SHIELD_NO_BANNER = defineDefaultBlockingType(new NonBannerShieldBlockingType("shield_no_banner"));
+	public static final BlockingType CURRENT_SHIELD = defineDefaultBlockingType(new CurrentShieldBlockingType("current_shield"));
+	public static final BlockingType NEW_SHIELD = defineDefaultBlockingType(new NewShieldBlockingType("new_shield").setKbMechanics(false));
+	public static final BlockingType EMPTY = new EmptyBlockingType("empty").setDisablement(false).setCrouchable(false).setRequireFullCharge(false).setKbMechanics(false);
+
+	public static void onInitialize() {
+		WeaponType.init();
+	}
+	public static void defineDefaultWeaponType(WeaponType type) {
+		defaultWeaponTypes.put(type.name, type);
+	}
+	public static <T extends BlockingType> T defineDefaultBlockingType(T blockingType) {
+		defaultTypes.put(blockingType.getName(), blockingType);
+		return blockingType;
+	}
+}
diff --git a/src/main/java/net/atlas/combatify/util/BlockingType.java b/src/main/java/net/atlas/combatify/util/BlockingType.java
new file mode 100644
index 0000000000000000000000000000000000000000..b509299c2d65ad2302290fae27f1c23c21b2e3ec
--- /dev/null
+++ b/src/main/java/net/atlas/combatify/util/BlockingType.java
@@ -0,0 +1,139 @@
+package net.atlas.combatify.util;
+
+import net.minecraft.ChatFormatting;
+import net.minecraft.network.chat.CommonComponents;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.InteractionResultHolder;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.ai.attributes.AttributeModifier;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.*;
+import net.minecraft.world.item.component.ItemAttributeModifiers;
+import net.minecraft.world.level.Level;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Objects;
+import java.util.function.Consumer;
+
+import static net.atlas.combatify.Combatify.EMPTY;
+
+public abstract class BlockingType {
+	private final String name;
+	private boolean canBeDisabled = true;
+	private boolean canCrouchBlock = true;
+	private boolean isToolBlocker = false;
+	private boolean canBlockHit = false;
+	private boolean requiresSwordBlocking = false;
+	private boolean requireFullCharge = true;
+	private boolean defaultKbMechanics = true;
+	private boolean hasDelay = true;
+	public boolean canCrouchBlock() {
+		return canCrouchBlock;
+	}
+	public BlockingType setCrouchable(boolean crouchable) {
+		canCrouchBlock = crouchable;
+		return this;
+	}
+
+	public boolean canBlockHit() {
+		return canBlockHit;
+	}
+	public BlockingType setBlockHit(boolean blockHit) {
+		canBlockHit = blockHit;
+		return this;
+	}
+	public boolean isToolBlocker() {
+		return isToolBlocker;
+	}
+	public BlockingType setToolBlocker(boolean isTool) {
+		isToolBlocker = isTool;
+		return this;
+	}
+	public boolean canBeDisabled() {
+		return canBeDisabled;
+	}
+	public BlockingType setDisablement(boolean canDisable) {
+		canBeDisabled = canDisable;
+		return this;
+	}
+	public boolean requireFullCharge() {
+		return requireFullCharge;
+	}
+	public BlockingType setRequireFullCharge(boolean needsFullCharge) {
+		requireFullCharge = needsFullCharge;
+		return this;
+	}
+	public boolean defaultKbMechanics() {
+		return defaultKbMechanics;
+	}
+	public BlockingType setKbMechanics(boolean defaultKbMechanics) {
+		this.defaultKbMechanics = defaultKbMechanics;
+		return this;
+	}
+	public boolean requiresSwordBlocking() {
+		return requiresSwordBlocking;
+	}
+	public BlockingType setSwordBlocking(boolean requiresSwordBlocking) {
+		this.requiresSwordBlocking = requiresSwordBlocking;
+		return this;
+	}
+	public boolean hasDelay() {
+		return hasDelay;
+	}
+	public BlockingType setDelay(boolean hasDelay) {
+		this.hasDelay = hasDelay;
+		return this;
+	}
+
+	public BlockingType(String name) {
+		this.name = name;
+	}
+	public boolean isEmpty() {
+		return this == EMPTY;
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	@Override
+	public boolean equals(Object o) {
+		if (this == o) return true;
+		if (!(o instanceof BlockingType that)) return false;
+		return canBeDisabled == that.canBeDisabled && canCrouchBlock == that.canCrouchBlock && isToolBlocker() == that.isToolBlocker() && canBlockHit == that.canBlockHit && requiresSwordBlocking == that.requiresSwordBlocking && requireFullCharge == that.requireFullCharge && defaultKbMechanics == that.defaultKbMechanics && Objects.equals(getName(), that.getName());
+	}
+
+	@Override
+	public int hashCode() {
+		return Objects.hash(getName(), canBeDisabled, canCrouchBlock, isToolBlocker(), canBlockHit, requiresSwordBlocking, requireFullCharge, defaultKbMechanics);
+	}
+
+	public abstract float getBlockedDamage(LivingEntity instance, @Nullable Entity entity, ItemStack blockingItem, DamageSource source, Double amount, float originalAmount);
+    public abstract boolean wasBlockedByShield(LivingEntity instance, @Nullable Entity entity, ItemStack blockingItem, DamageSource source);
+	public abstract float getShieldBlockDamageValue(ItemStack stack);
+	public abstract double getShieldKnockbackResistanceValue(ItemStack stack);
+	public abstract @NotNull InteractionResultHolder<ItemStack> use(Level world, Player user, InteractionHand hand);
+	public abstract boolean canUse(Level world, Player user, InteractionHand hand);
+	public void appendTooltipInfo(Consumer<Component> consumer, Player player, ItemStack stack) {
+		consumer.accept(CommonComponents.EMPTY);
+		consumer.accept(Component.translatable("item.modifiers.use").withStyle(ChatFormatting.GRAY));
+		float f = getShieldBlockDamageValue(stack);
+		double g = getShieldKnockbackResistanceValue(stack);
+		consumer.accept(CommonComponents.space().append(
+			Component.translatable("attribute.modifier.equals." + AttributeModifier.Operation.ADD_VALUE.id(),
+				ItemAttributeModifiers.ATTRIBUTE_MODIFIER_FORMAT.format(f),
+				getStrengthTranslationKey())).withStyle(ChatFormatting.DARK_GREEN));
+		if (g > 0.0)
+			consumer.accept(CommonComponents.space().append(
+				Component.translatable("attribute.modifier.equals." + AttributeModifier.Operation.ADD_VALUE.id(),
+					ItemAttributeModifiers.ATTRIBUTE_MODIFIER_FORMAT.format(g * 10.0),
+					Component.translatable("attribute.name.generic.knockback_resistance"))).withStyle(ChatFormatting.DARK_GREEN));
+	}
+	public Component getStrengthTranslationKey() {
+		return Component.translatable("attribute.name.generic.shield_strength");
+	}
+}
diff --git a/src/main/java/net/atlas/combatify/util/FakeUseItem.java b/src/main/java/net/atlas/combatify/util/FakeUseItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..576e42a14e4f32bb9cae6eb522585297912d5f96
--- /dev/null
+++ b/src/main/java/net/atlas/combatify/util/FakeUseItem.java
@@ -0,0 +1,11 @@
+package net.atlas.combatify.util;
+
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+
+public record FakeUseItem(ItemStack stack, InteractionHand useHand) {
+	public Item getItem() {
+		return stack.getItem();
+	}
+}
diff --git a/src/main/java/net/atlas/combatify/util/MethodHandler.java b/src/main/java/net/atlas/combatify/util/MethodHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..83978ef3ff1b239bf706dc3bd1e1e58a26ae9e4a
--- /dev/null
+++ b/src/main/java/net/atlas/combatify/util/MethodHandler.java
@@ -0,0 +1,285 @@
+package net.atlas.combatify.util;
+
+import net.atlas.combatify.Combatify;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.syncher.EntityDataAccessor;
+import net.minecraft.sounds.SoundEvents;
+import net.minecraft.util.Mth;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntitySelector;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.ai.attributes.AttributeInstance;
+import net.minecraft.world.entity.ai.attributes.AttributeModifier;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.entity.projectile.ProjectileUtil;
+import net.minecraft.world.entity.projectile.ThrownTrident;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.UseAnim;
+import net.minecraft.world.level.ClipContext;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.*;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.BiConsumer;
+
+public class MethodHandler {
+	public static float getAttackStrengthScale(LivingEntity entity, float baseTime) {
+		if (entity instanceof Player player)
+			return player.getAttackStrengthScale(baseTime);
+		return 2.0f;
+	}
+	public static Vec3 getNearestPointTo(AABB box, Vec3 vec3) {
+		double x = Mth.clamp(vec3.x, box.minX, box.maxX);
+		double y = Mth.clamp(vec3.y, box.minY, box.maxY);
+		double z = Mth.clamp(vec3.z, box.minZ, box.maxZ);
+
+		return new Vec3(x, y, z);
+	}
+
+	public static double calculateValue(@Nullable AttributeInstance attributeInstance, float damageBonus) {
+		if(attributeInstance == null)
+			return damageBonus;
+		double attributeInstanceBaseValue = attributeInstance.getBaseValue() + damageBonus;
+
+		for(AttributeModifier attributeModifier : attributeInstance.getModifiersOrEmpty(AttributeModifier.Operation.ADD_VALUE)) {
+			attributeInstanceBaseValue += attributeModifier.amount();
+		}
+
+		return calculateValueFromBase(attributeInstance, attributeInstanceBaseValue);
+	}
+	public static double calculateValueFromBase(@Nullable AttributeInstance attributeInstance, double attributeInstanceBaseValue) {
+		if(attributeInstance == null)
+			return attributeInstanceBaseValue;
+
+		double attributeInstanceFinalValue = attributeInstanceBaseValue;
+
+		for(AttributeModifier attributeModifier2 : attributeInstance.getModifiersOrEmpty(AttributeModifier.Operation.ADD_MULTIPLIED_BASE)) {
+			attributeInstanceFinalValue += attributeInstanceBaseValue * attributeModifier2.amount();
+		}
+
+		for(AttributeModifier attributeModifier2 : attributeInstance.getModifiersOrEmpty(AttributeModifier.Operation.ADD_MULTIPLIED_TOTAL)) {
+			attributeInstanceFinalValue *= 1.0 + attributeModifier2.amount();
+		}
+
+		return attributeInstance.getAttribute().value().sanitizeValue(attributeInstanceFinalValue);
+	}
+	public static float getFatigueForTime(int f) {
+		if (f < 60)
+			return 0.5F;
+		else
+			return f >= 200 ? 10.5F : 0.5F + 10.0F * (float)(f - 60) / 140.0F;
+	}
+	public static void knockback(LivingEntity entity, double strength, double x, double z) {
+		double knockbackRes = entity.getAttributeValue(Attributes.KNOCKBACK_RESISTANCE);
+		ItemStack blockingItem = getBlockingItem(entity).stack();
+        if (!blockingItem.isEmpty()) {
+			BlockingType blockingType = blockingItem.getItem().getBlockingType();
+			if (!blockingType.defaultKbMechanics())
+				knockbackRes = Math.max(knockbackRes, blockingType.getShieldKnockbackResistanceValue(blockingItem));
+			else
+				knockbackRes = Math.min(1.0, knockbackRes + blockingType.getShieldKnockbackResistanceValue(blockingItem));
+		}
+
+		strength *= 1.0 - knockbackRes;
+		if (!(strength <= 0.0F)) {
+			entity.hasImpulse = true;
+			Vec3 delta = entity.getDeltaMovement();
+			Vec3 diff = (new Vec3(x, 0.0, z)).normalize().scale(strength);
+			entity.setDeltaMovement(delta.x / 2.0 - diff.x, entity.onGround() ? Math.min(0.4, strength * 0.75) : Math.min(0.4, delta.y + strength * 0.5), delta.z / 2.0 - diff.z);
+		}
+	}
+	public static void projectileKnockback(LivingEntity entity, double strength, double x, double z) {
+		double knockbackRes = entity.getAttributeValue(Attributes.KNOCKBACK_RESISTANCE);
+
+		strength *= 1.0 - knockbackRes;
+		if (!(strength <= 0.0F)) {
+			entity.hasImpulse = true;
+			Vec3 delta = entity.getDeltaMovement();
+			Vec3 diff = (new Vec3(x, 0.0, z)).normalize().scale(strength);
+			entity.setDeltaMovement(delta.x / 2.0 - diff.x, Math.min(0.4, strength * 0.75), delta.z / 2.0 - diff.z);
+		}
+	}
+	private static List<BlockPos> clip(Level level, ClipContext clipContext) {
+		List<BlockPos> blockPosList = new ArrayList<>();
+		traverseBlocks(clipContext.getFrom(), clipContext.getTo(), clipContext, (clipContextx, blockPos) -> {
+			BlockState blockState = level.getBlockState(blockPos);
+            if (blockState.canOcclude() && blockState.getBlock().hasCollision)
+				blockPosList.add(blockPos);
+		});
+		return blockPosList;
+	}
+	private static <C> void traverseBlocks(Vec3 vec3, Vec3 vec32, C object, BiConsumer<C, BlockPos> biConsumer) {
+		if (!vec3.equals(vec32)) {
+			double d = Mth.lerp(-1.0E-7, vec3.x, vec32.x);
+			double e = Mth.lerp(-1.0E-7, vec3.y, vec32.y);
+			double f = Mth.lerp(-1.0E-7, vec3.z, vec32.z);
+			int g = Mth.floor(d);
+			int h = Mth.floor(e);
+			int i = Mth.floor(f);
+			BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos(g, h, i);
+			biConsumer.accept(object, mutableBlockPos);
+			double j = Mth.lerp(-1.0E-7, vec32.x, vec3.x) - d;
+			double k = Mth.lerp(-1.0E-7, vec32.y, vec3.y) - e;
+			double l = Mth.lerp(-1.0E-7, vec32.z, vec3.z) - f;
+			int m = Mth.sign(j);
+			int n = Mth.sign(k);
+			int o = Mth.sign(l);
+			double p = m == 0 ? Double.MAX_VALUE : (double)m / j;
+			double q = n == 0 ? Double.MAX_VALUE : (double)n / k;
+			double r = o == 0 ? Double.MAX_VALUE : (double)o / l;
+			double s = p * (m > 0 ? 1.0 - Mth.frac(d) : Mth.frac(d));
+			double t = q * (n > 0 ? 1.0 - Mth.frac(e) : Mth.frac(e));
+			double u = r * (o > 0 ? 1.0 - Mth.frac(f) : Mth.frac(f));
+
+			do {
+				if (s < t) {
+					if (s < u) {
+						g += m;
+						s += p;
+					} else {
+						i += o;
+						u += r;
+					}
+				} else if (t < u) {
+					h += n;
+					t += q;
+				} else {
+					i += o;
+					u += r;
+				}
+
+				biConsumer.accept(object, mutableBlockPos.set(g, h, i));
+			} while(s <= 1.0 || t <= 1.0 || u <= 1.0);
+		}
+	}
+	public static List<BlockPos> pickFromPos(Entity entity, double reach) {
+		Vec3 viewVector = entity.getViewVector(1);
+		Vec3 pos = entity.getEyePosition(1);
+		Vec3 endPos = pos.add(viewVector.scale(reach));
+		return clip(entity.level(), new ClipContext(pos, endPos, ClipContext.Block.OUTLINE, ClipContext.Fluid.NONE, entity));
+	}
+	public static EntityHitResult rayTraceEntity(Entity entity, float partialTicks, double blockReachDistance) {
+		Vec3 from = entity.getEyePosition(partialTicks);
+		Vec3 look = entity.getViewVector(partialTicks);
+		Vec3 to = from.add(look.x * blockReachDistance, look.y * blockReachDistance, look.z * blockReachDistance);
+
+		return ProjectileUtil.getEntityHitResult(
+			entity.level(),
+			entity,
+			from,
+			to,
+			new AABB(from, to),
+			EntitySelector.NO_CREATIVE_OR_SPECTATOR.and(e -> e != null
+				&& e.isPickable()
+				&& e instanceof LivingEntity)
+		);
+	}
+	public static HitResult redirectResult(Player player, HitResult instance) {
+		if (instance.getType() == HitResult.Type.BLOCK) {
+			BlockHitResult blockHitResult = (BlockHitResult) instance;
+			BlockPos blockPos = blockHitResult.getBlockPos();
+			Level level = player.level();
+			boolean bl = !level.getBlockState(blockPos).canOcclude() && !level.getBlockState(blockPos).getBlock().hasCollision;
+			EntityHitResult rayTraceResult = MethodHandler.rayTraceEntity(player, 1.0F, getCurrentAttackReach(player, 0.0F));
+			if (rayTraceResult != null && bl) {
+				double distanceTo = player.distanceTo(rayTraceResult.getEntity());
+				List<BlockPos> blockPosList = pickFromPos(player, distanceTo);
+				if (!blockPosList.isEmpty())
+					return instance;
+				return rayTraceResult;
+			} else {
+				return instance;
+			}
+		}
+		return instance;
+	}
+	public static void disableShield(LivingEntity attacker, LivingEntity target, ItemStack blockingItem) {
+		boolean canDisable = attacker.canDisableShield();
+		Item shieldItem = blockingItem.getItem();
+		if (canDisable && shieldItem.getBlockingType().canBeDisabled()) {
+			float damage = 1.6F + (float) attacker.getAttributeValue(Attributes.SHIELD_DISABLE_TIME);
+			damage -= (float) (target.getAttributeValue(CustomAttributes.SHIELD_DISABLE_REDUCTION));
+			if (target instanceof PlayerExtensions player)
+				player.ctsShieldDisable(damage, blockingItem.getItem());
+		}
+	}
+	public static void arrowDisable(LivingEntity target, ItemStack blockingItem) {
+		float damage = Combatify.CONFIG.shieldDisableTime().floatValue();
+		damage -= (float) (target.getAttributeValue(CustomAttributes.SHIELD_DISABLE_REDUCTION));
+		if (target instanceof PlayerExtensions player)
+			player.ctsShieldDisable(damage, blockingItem.getItem());
+	}
+	public static FakeUseItem getBlockingItem(LivingEntity entity) {
+		if (entity.isUsingItem() && !entity.getUseItem().isEmpty()) {
+			if (entity.getUseItem().getUseAnimation() == UseAnim.BLOCK) {
+				return new FakeUseItem(entity.getUseItem(), entity.getUsedItemHand());
+			}
+		} else if (((entity.onGround() && entity.isCrouching()) || entity.isPassenger()) && entity.hasEnabledShieldOnCrouch()) {
+			for (InteractionHand hand : InteractionHand.values()) {
+				ItemStack stack = entity.getItemInHand(hand);
+				if (!stack.isEmpty() && stack.getUseAnimation() == UseAnim.BLOCK && !isItemOnCooldown(entity, stack) && stack.getItem().getBlockingType().canCrouchBlock()) {
+					return new FakeUseItem(stack, hand);
+				}
+			}
+		}
+
+		return new FakeUseItem(ItemStack.EMPTY, null);
+	}
+	public static boolean isItemOnCooldown(LivingEntity entity, ItemStack var1) {
+		return entity instanceof Player player && player.getCooldowns().isOnCooldown(var1.getItem());
+	}
+	public static double getCurrentAttackReach(Player player, float baseTime) {
+		@Nullable final var attackRange = player.getAttribute(Attributes.ENTITY_INTERACTION_RANGE);
+		double chargedBonus = 0;
+		double baseAttackRange = 2.5;
+		float strengthScale = player.getAttackStrengthScale(baseTime);
+		float charge = 1.95F;
+		if (attackRange != null) {
+			Item item = player.getItemInHand(InteractionHand.MAIN_HAND).getItem();
+			chargedBonus = 1.0;
+			AttributeModifier modifier = new AttributeModifier(Combatify.CHARGED_REACH_ID, chargedBonus, AttributeModifier.Operation.ADD_VALUE);
+			if (strengthScale > charge && !player.isCrouching())
+				attackRange.addOrUpdateTransientModifier(modifier);
+			else
+				attackRange.removeModifier(modifier);
+		}
+		if (strengthScale < charge || player.isCrouching()) {
+			chargedBonus = 0;
+		}
+		return (attackRange != null) ? attackRange.getValue() : baseAttackRange + chargedBonus;
+	}
+	public static void voidReturnLogic(ThrownTrident trident, EntityDataAccessor<Byte> ID_LOYALTY) {
+		int j = trident.getEntityData().get(ID_LOYALTY);
+		if (trident.getY() <= -65 && j > 0) {
+			if (!trident.isAcceptibleReturnOwner()) {
+				trident.discard();
+			} else {
+				trident.setNoPhysics(true);
+				Vec3 vec3 = trident.getEyePosition().subtract(trident.position());
+				trident.setPosRaw(trident.getX(), trident.getY() + vec3.y * 0.015 * j, trident.getZ());
+				if (trident.level().isClientSide) {
+					trident.yOld = trident.getY();
+				}
+
+				double d = 0.05 * j;
+				trident.setDeltaMovement(trident.getDeltaMovement().scale(0.95).add(vec3.normalize().scale(d)));
+				if (trident.clientSideReturnTridentTickCount == 0) {
+					trident.playSound(SoundEvents.TRIDENT_RETURN, 10.0F, 1.0F);
+				}
+
+				++trident.clientSideReturnTridentTickCount;
+			}
+		}
+	}
+	public static Vec3 project(Vec3 originalVec, Vec3 newVec) {
+	    Vec3 normalized = newVec.normalize();
+	    double d = originalVec.dot(newVec);
+	    return normalized.multiply(d, d, d);
+	}
+}
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 30f4f1254fc295442d72d50479e8af635f2fe983..ae9737f5ab00bee12b69c6b64c173c768784b856 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -25,6 +25,9 @@ import java.util.Set;
 import java.util.function.Predicate;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
+
+import net.atlas.combatify.util.BlockingType;
+import net.atlas.combatify.util.MethodHandler;
 import net.minecraft.BlockUtil;
 import net.minecraft.Util;
 import net.minecraft.advancements.CriteriaTriggers;
@@ -307,7 +310,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
         this.lastBodyItemStack = ItemStack.EMPTY;
         this.discardFriction = false;
         this.walkAnimation = new WalkAnimationState();
-        this.invulnerableDuration = 20;
+        this.invulnerableDuration = 10;
         this.effectsDirty = true;
         this.useItem = ItemStack.EMPTY;
         this.lastClimbablePos = Optional.empty();
@@ -906,6 +909,10 @@ public abstract class LivingEntity extends Entity implements Attackable {
     private boolean isTickingEffects = false;
     private List<ProcessableEffect> effectsToProcess = Lists.newArrayList();
 
+    public boolean hasEnabledShieldOnCrouch() {
+        return false; // Combatify - Save me
+    }
+
     private static class ProcessableEffect {
 
         private Holder<MobEffect> type;
@@ -1426,7 +1433,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
 
             this.noActionTime = 0;
             float f1 = amount; final float originalAmount = f1; // Paper - revert to vanilla #hurt - OBFHELPER
-            boolean flag = amount > 0.0F && this.isDamageSourceBlocked(source); // Copied from below
+            boolean flag = MethodHandler.getBlockingItem(this).getItem().getBlockingType().wasBlockedByShield(this, null, MethodHandler.getBlockingItem(this).stack(), source); // Copied from below
             float f2 = 0.0F;
 
             // CraftBukkit - Moved into handleEntityDamage(DamageSource, float) for get f and actuallyHurt(DamageSource, float, EntityDamageEvent) for handle damage
@@ -1465,7 +1472,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
             this.walkAnimation.setSpeed(1.5F);
             boolean flag1 = true;
 
-            if ((float) this.invulnerableTime > (float) this.invulnerableDuration / 2.0F && !source.is(DamageTypeTags.BYPASSES_COOLDOWN)) { // CraftBukkit - restore use of maxNoDamageTicks
+            if ((float) this.invulnerableTime >= 0 && !source.is(DamageTypeTags.BYPASSES_COOLDOWN)) { // Combatify - Invulnerable time is now always based on full duration
                 if (amount <= this.lastHurt) {
                     return false;
                 }
@@ -1492,9 +1499,15 @@ public abstract class LivingEntity extends Entity implements Attackable {
                 if (!this.actuallyHurt(source, (float) event.getFinalDamage(), event)) {
                     return false;
                 }
-                if (this instanceof ServerPlayer && event.getDamage() == 0 && originalAmount == 0) return false; // Paper - revert to vanilla damage - players are not affected by damage that is 0 - skip damage if the vanilla damage is 0 and was not modified by plugins in the event.
                 this.lastHurt = amount;
                 this.invulnerableTime = this.invulnerableDuration; // CraftBukkit - restore use of maxNoDamageTicks
+                // Combatify start - Alter I-Frames conditionally
+                if (source.getDirectEntity() instanceof net.minecraft.world.entity.player.Player player) {
+                    int base = (int) Math.min(player.getCurrentItemAttackStrengthDelay(), invulnerableTime);
+                    invulnerableTime = base >= 4 ? base - 2 : base;
+                }
+                if (source.is(DamageTypeTags.IS_PROJECTILE)) invulnerableTime = 0;
+                // Combatify end
                 // this.actuallyHurt(damagesource, f);
                 // CraftBukkit end
                 this.hurtDuration = 10;
@@ -1955,8 +1968,18 @@ public abstract class LivingEntity extends Entity implements Attackable {
     }
 
     public void knockback(double d0, double d1, double d2, @Nullable Entity attacker, io.papermc.paper.event.entity.EntityKnockbackEvent.Cause cause) { // Paper - knockback events
-        d0 *= 1.0D - this.getAttributeValue(Attributes.KNOCKBACK_RESISTANCE);
-        if (true || d0 > 0.0D) { // CraftBukkit - Call event even when force is 0
+        double knockbackRes = this.getAttributeValue(Attributes.KNOCKBACK_RESISTANCE);
+        ItemStack blockingItem = MethodHandler.getBlockingItem(this).stack();
+        if (!blockingItem.isEmpty()) {
+            BlockingType blockingType = blockingItem.getItem().getBlockingType();
+            if (!blockingType.defaultKbMechanics())
+                knockbackRes = Math.max(knockbackRes, blockingType.getShieldKnockbackResistanceValue(blockingItem));
+            else
+                knockbackRes = Math.min(1.0, knockbackRes + blockingType.getShieldKnockbackResistanceValue(blockingItem));
+        }
+
+        d0 *= 1.0D - knockbackRes;
+        if (true || d0 > 0.0) { // CraftBukkit - Call event even when force is 0
             //this.hasImpulse = true; // CraftBukkit - Move down
 
             Vec3 vec3d;
@@ -1968,7 +1991,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
             Vec3 vec3d1 = (new Vec3(d1, 0.0D, d2)).normalize().scale(d0);
 
             // Paper start - knockback events
-            Vec3 finalVelocity = new Vec3(vec3d.x / 2.0D - vec3d1.x, this.onGround() ? Math.min(0.4D, vec3d.y / 2.0D + d0) : vec3d.y, vec3d.z / 2.0D - vec3d1.z);
+            Vec3 finalVelocity = new Vec3(vec3d.x / 2.0D - vec3d1.x, this.onGround() ? Math.min(0.4D, d0 * 0.75) : Math.min(0.4, vec3d.y + (d0 * 0.5)), vec3d.z / 2.0D - vec3d1.z); // Combatify - Alter base knockback
             Vec3 diff = finalVelocity.subtract(vec3d);
             io.papermc.paper.event.entity.EntityKnockbackEvent event = CraftEventFactory.callEntityKnockbackEvent((org.bukkit.craftbukkit.entity.CraftLivingEntity) this.getBukkitEntity(), attacker, attacker, cause, d0, diff);
             // Paper end - knockback events
@@ -2250,78 +2273,58 @@ public abstract class LivingEntity extends Entity implements Attackable {
     private EntityDamageEvent handleEntityDamage(final DamageSource damagesource, float f) {
         float originalDamage = f;
 
-        Function<Double, Double> freezing = new Function<Double, Double>() {
-            @Override
-            public Double apply(Double f) {
-                if (damagesource.is(DamageTypeTags.IS_FREEZING) && LivingEntity.this.getType().is(EntityTypeTags.FREEZE_HURTS_EXTRA_TYPES)) {
-                    return -(f - (f * 5.0F));
-                }
-                return -0.0;
+        Function<Double, Double> freezing = f17 -> {
+            if (damagesource.is(DamageTypeTags.IS_FREEZING) && LivingEntity.this.getType().is(EntityTypeTags.FREEZE_HURTS_EXTRA_TYPES)) {
+                return -(f17 - (f17 * 5.0F));
             }
+            return -0.0;
         };
         float freezingModifier = freezing.apply((double) f).floatValue();
         f += freezingModifier;
 
-        Function<Double, Double> hardHat = new Function<Double, Double>() {
-            @Override
-            public Double apply(Double f) {
-                if (damagesource.is(DamageTypeTags.DAMAGES_HELMET) && !LivingEntity.this.getItemBySlot(EquipmentSlot.HEAD).isEmpty()) {
-                    return -(f - (f * 0.75F));
-                }
-                return -0.0;
+        Function<Double, Double> hardHat = f16 -> {
+            if (damagesource.is(DamageTypeTags.DAMAGES_HELMET) && !LivingEntity.this.getItemBySlot(EquipmentSlot.HEAD).isEmpty()) {
+                return -(f16 - (f16 * 0.75F));
             }
+            return -0.0;
         };
         float hardHatModifier = hardHat.apply((double) f).floatValue();
         f += hardHatModifier;
 
-        Function<Double, Double> blocking = new Function<Double, Double>() {
-            @Override
-            public Double apply(Double f) {
-                return -((LivingEntity.this.isDamageSourceBlocked(damagesource)) ? f : 0.0);
+        // Combatify start
+        Function<Double, Double> blocking = f15 -> {
+            ItemStack itemStack = MethodHandler.getBlockingItem(LivingEntity.this).stack();
+            Item shieldItem = itemStack.getItem();
+            if (originalDamage > 0.0F && isDamageSourceBlocked(damagesource)) {
+                return (double) -shieldItem.getBlockingType().getBlockedDamage(this, null, itemStack, damagesource, f15, originalDamage);
             }
+            return -0.0;
         };
+        // Combatify end
         float blockingModifier = blocking.apply((double) f).floatValue();
         f += blockingModifier;
 
-        Function<Double, Double> armor = new Function<Double, Double>() {
-            @Override
-            public Double apply(Double f) {
-                return -(f - LivingEntity.this.getDamageAfterArmorAbsorb(damagesource, f.floatValue()));
-            }
-        };
+        Function<Double, Double> armor = f15 -> -(f15 - LivingEntity.this.getDamageAfterArmorAbsorb(damagesource, f15.floatValue()));
         float armorModifier = armor.apply((double) f).floatValue();
         f += armorModifier;
 
-        Function<Double, Double> resistance = new Function<Double, Double>() {
-            @Override
-            public Double apply(Double f) {
-                if (!damagesource.is(DamageTypeTags.BYPASSES_EFFECTS) && LivingEntity.this.hasEffect(MobEffects.DAMAGE_RESISTANCE) && !damagesource.is(DamageTypeTags.BYPASSES_RESISTANCE)) {
-                    int i = (LivingEntity.this.getEffect(MobEffects.DAMAGE_RESISTANCE).getAmplifier() + 1) * 5;
-                    int j = 25 - i;
-                    float f1 = f.floatValue() * (float) j;
-                    return -(f - (f1 / 25.0F));
-                }
-                return -0.0;
+        Function<Double, Double> resistance = f14 -> {
+            if (!damagesource.is(DamageTypeTags.BYPASSES_EFFECTS) && LivingEntity.this.hasEffect(MobEffects.DAMAGE_RESISTANCE) && !damagesource.is(DamageTypeTags.BYPASSES_RESISTANCE)) {
+                int i = (LivingEntity.this.getEffect(MobEffects.DAMAGE_RESISTANCE).getAmplifier() + 1) * 5;
+                int j = 25 - i;
+                float f1 = f14.floatValue() * (float) j;
+                return -(f14 - (f1 / 25.0F));
             }
+            return -0.0;
         };
         float resistanceModifier = resistance.apply((double) f).floatValue();
         f += resistanceModifier;
 
-        Function<Double, Double> magic = new Function<Double, Double>() {
-            @Override
-            public Double apply(Double f) {
-                return -(f - LivingEntity.this.getDamageAfterMagicAbsorb(damagesource, f.floatValue()));
-            }
-        };
+        Function<Double, Double> magic = f13 -> -(f13 - LivingEntity.this.getDamageAfterMagicAbsorb(damagesource, f13.floatValue()));
         float magicModifier = magic.apply((double) f).floatValue();
         f += magicModifier;
 
-        Function<Double, Double> absorption = new Function<Double, Double>() {
-            @Override
-            public Double apply(Double f) {
-                return -(Math.max(f - Math.max(f - LivingEntity.this.getAbsorptionAmount(), 0.0F), 0.0F));
-            }
-        };
+        Function<Double, Double> absorption = f12 -> -(Math.max(f12 - Math.max(f12 - LivingEntity.this.getAbsorptionAmount(), 0.0F), 0.0F));
         float absorptionModifier = absorption.apply((double) f).floatValue();
 
         return CraftEventFactory.handleLivingEntityDamageEvent(this, damagesource, originalDamage, freezingModifier, hardHatModifier, blockingModifier, armorModifier, resistanceModifier, magicModifier, absorptionModifier, freezing, hardHat, blocking, armor, resistance, magic, absorption);
@@ -2554,7 +2557,6 @@ public abstract class LivingEntity extends Entity implements Attackable {
                 this.playSound(SoundEvents.SHIELD_BREAK, 0.8F, 0.8F + this.level().random.nextFloat() * 0.4F);
                 break;
             case 46:
-                boolean flag = true;
 
                 for (int i = 0; i < 128; ++i) {
                     double d0 = (double) i / 127.0D;
@@ -2691,7 +2693,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
         } else if (hand == InteractionHand.OFF_HAND) {
             return this.getItemBySlot(EquipmentSlot.OFFHAND);
         } else {
-            throw new IllegalArgumentException("Invalid hand " + String.valueOf(hand));
+            throw new IllegalArgumentException("Invalid hand " + hand);
         }
     }
 
@@ -2700,7 +2702,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
             this.setItemSlot(EquipmentSlot.MAINHAND, stack);
         } else {
             if (hand != InteractionHand.OFF_HAND) {
-                throw new IllegalArgumentException("Invalid hand " + String.valueOf(hand));
+                throw new IllegalArgumentException("Invalid hand " + hand);
             }
 
             this.setItemSlot(EquipmentSlot.OFFHAND, stack);
@@ -4486,33 +4488,16 @@ public abstract class LivingEntity extends Entity implements Attackable {
     }
 
     public static byte entityEventForEquipmentBreak(EquipmentSlot slot) {
-        byte b0;
-
-        switch (slot) {
-            case MAINHAND:
-                b0 = 47;
-                break;
-            case OFFHAND:
-                b0 = 48;
-                break;
-            case HEAD:
-                b0 = 49;
-                break;
-            case CHEST:
-                b0 = 50;
-                break;
-            case FEET:
-                b0 = 52;
-                break;
-            case LEGS:
-                b0 = 51;
-                break;
-            case BODY:
-                b0 = 65;
-                break;
-            default:
-                throw new MatchException((String) null, (Throwable) null);
-        }
+        byte b0 = switch (slot) {
+            case MAINHAND -> 47;
+            case OFFHAND -> 48;
+            case HEAD -> 49;
+            case CHEST -> 50;
+            case FEET -> 52;
+            case LEGS -> 51;
+            case BODY -> 65;
+            default -> throw new MatchException((String) null, (Throwable) null);
+        };
 
         return b0;
     }
@@ -4528,8 +4513,6 @@ public abstract class LivingEntity extends Entity implements Attackable {
     @Override
     public AABB getBoundingBoxForCulling() {
         if (this.getItemBySlot(EquipmentSlot.HEAD).is(Items.DRAGON_HEAD)) {
-            float f = 0.5F;
-
             return this.getBoundingBox().inflate(0.5D, 0.5D, 0.5D);
         } else {
             return super.getBoundingBoxForCulling();
diff --git a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeInstance.java b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeInstance.java
index d28f9e077a50122e86848cfa9db83f6b0e8eef6c..07ae4c7582c744e57e6800c740b3fd1ae8272f01 100644
--- a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeInstance.java
+++ b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeInstance.java
@@ -159,7 +159,7 @@ public class AttributeInstance {
         return attribute.value().sanitizeValue(e); // Paper - destroy speed API - diff on change
     }
 
-    private Collection<AttributeModifier> getModifiersOrEmpty(AttributeModifier.Operation operation) {
+    public Collection<AttributeModifier> getModifiersOrEmpty(AttributeModifier.Operation operation) {
         return this.modifiersByOperation.getOrDefault(operation, Map.of()).values();
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/projectile/ThrownTrident.java b/src/main/java/net/minecraft/world/entity/projectile/ThrownTrident.java
index 44c733c5b2c3e9942f28e882ad72306a24459c2c..f6269e9ef7f76ca02871307d5864d16375c385fc 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/ThrownTrident.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/ThrownTrident.java
@@ -99,7 +99,7 @@ public class ThrownTrident extends AbstractArrow {
         super.tick();
     }
 
-    private boolean isAcceptibleReturnOwner() {
+    public boolean isAcceptibleReturnOwner() {
         Entity entity = this.getOwner();
 
         return entity != null && entity.isAlive() ? !(entity instanceof ServerPlayer) || !entity.isSpectator() : false;
diff --git a/src/main/java/net/minecraft/world/item/ShieldItem.java b/src/main/java/net/minecraft/world/item/ShieldItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..4fae9f71851a09f2807eb185ea4fd68cc6c1014c
--- /dev/null
+++ b/src/main/java/net/minecraft/world/item/ShieldItem.java
@@ -0,0 +1,69 @@
+package net.minecraft.world.item;
+
+import net.atlas.combatify.Combatify;
+import net.atlas.combatify.util.BlockingType;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.network.chat.Component;
+import net.minecraft.tags.ItemTags;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.InteractionResultHolder;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.DispenserBlock;
+
+import java.util.List;
+
+public class ShieldItem extends Item implements Equipable {
+    public static final int EFFECTIVE_BLOCK_DELAY = 5;
+    public static final float MINIMUM_DURABILITY_DAMAGE = 3.0F;
+
+    public ShieldItem(Properties settings) {
+        super(settings);
+        DispenserBlock.registerBehavior(this, ArmorItem.DISPENSE_ITEM_BEHAVIOR);
+    }
+
+    @Override
+    public String getDescriptionId(ItemStack stack) {
+        DyeColor dyeColor = stack.get(DataComponents.BASE_COLOR);
+        return dyeColor != null ? this.getDescriptionId() + "." + dyeColor.getName() : super.getDescriptionId(stack);
+    }
+
+    @Override
+    public void appendHoverText(ItemStack stack, TooltipContext context, List<Component> tooltip, TooltipFlag type) {
+        BannerItem.appendHoverTextFromBannerBlockEntityTag(stack, tooltip);
+    }
+
+    @Override
+    public BlockingType getBlockingType() {
+        return Combatify.SHIELD;
+    }
+
+    @Override
+    public UseAnim getUseAnimation(ItemStack stack) {
+        return UseAnim.BLOCK;
+    }
+
+    @Override
+    public int getUseDuration(ItemStack stack, LivingEntity user) {
+        return 72000;
+    }
+
+    @Override
+    public InteractionResultHolder<ItemStack> use(Level world, Player user, InteractionHand hand) {
+        ItemStack itemStack = user.getItemInHand(hand);
+        user.startUsingItem(hand);
+        return InteractionResultHolder.consume(itemStack);
+    }
+
+    @Override
+    public boolean isValidRepairItem(ItemStack stack, ItemStack ingredient) {
+        return ingredient.is(ItemTags.PLANKS) || super.isValidRepairItem(stack, ingredient);
+    }
+
+    @Override
+    public EquipmentSlot getEquipmentSlot() {
+        return EquipmentSlot.OFFHAND;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/item/Tier.java b/src/main/java/net/minecraft/world/item/Tier.java
new file mode 100644
index 0000000000000000000000000000000000000000..ca3a6dcb6a4b37b96bb15324e3280b425229794e
--- /dev/null
+++ b/src/main/java/net/minecraft/world/item/Tier.java
@@ -0,0 +1,27 @@
+package net.minecraft.world.item;
+
+import java.util.List;
+import net.minecraft.tags.TagKey;
+import net.minecraft.world.item.component.Tool;
+import net.minecraft.world.item.crafting.Ingredient;
+import net.minecraft.world.level.block.Block;
+
+public interface Tier {
+    int getUses();
+
+    float getSpeed();
+
+    float getAttackDamageBonus();
+
+    TagKey<Block> getIncorrectBlocksForDrops();
+
+    int getEnchantmentValue();
+
+    int getLevel();
+
+    Ingredient getRepairIngredient();
+
+    default Tool createToolProperties(TagKey<Block> tag) {
+        return new Tool(List.of(Tool.Rule.deniesDrops(this.getIncorrectBlocksForDrops()), Tool.Rule.minesAndDrops(tag, this.getSpeed())), 1.0F, 1);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/item/Tiers.java b/src/main/java/net/minecraft/world/item/Tiers.java
new file mode 100644
index 0000000000000000000000000000000000000000..abb465755130d128ff630a9f5b4fe302e4224e69
--- /dev/null
+++ b/src/main/java/net/minecraft/world/item/Tiers.java
@@ -0,0 +1,80 @@
+package net.minecraft.world.item;
+
+import com.google.common.base.Suppliers;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.tags.ItemTags;
+import net.minecraft.tags.TagKey;
+import net.minecraft.world.item.crafting.Ingredient;
+import net.minecraft.world.level.block.Block;
+
+import java.util.function.Supplier;
+
+public enum Tiers implements Tier {
+    WOOD(BlockTags.INCORRECT_FOR_WOODEN_TOOL, 59, 2.0F, 0.0F, 15, 0, () -> Ingredient.of(ItemTags.PLANKS)),
+    STONE(BlockTags.INCORRECT_FOR_STONE_TOOL, 131, 4.0F, 0.0F, 5, 1, () -> Ingredient.of(ItemTags.STONE_TOOL_MATERIALS)),
+    IRON(BlockTags.INCORRECT_FOR_IRON_TOOL, 250, 6.0F, 1.0F, 14, 2, () -> Ingredient.of(Items.IRON_INGOT)),
+    DIAMOND(BlockTags.INCORRECT_FOR_DIAMOND_TOOL, 1561, 8.0F, 2.0F, 10, 3, () -> Ingredient.of(Items.DIAMOND)),
+    GOLD(BlockTags.INCORRECT_FOR_GOLD_TOOL, 32, 12.0F, 0.0F, 22, 0, () -> Ingredient.of(Items.GOLD_INGOT)),
+    NETHERITE(BlockTags.INCORRECT_FOR_NETHERITE_TOOL, 2031, 9.0F, 3.0F, 15, 4, () -> Ingredient.of(Items.NETHERITE_INGOT));
+
+    private final TagKey<Block> incorrectBlocksForDrops;
+    private final int uses;
+    private final float speed;
+    private final float damage;
+    private final int enchantmentValue;
+    private final int level;
+    private final Supplier<Ingredient> repairIngredient;
+
+    Tiers(
+            final TagKey<Block> inverseTag,
+            final int itemDurability,
+            final float miningSpeed,
+            final float attackDamage,
+            final int enchantability,
+            final int level,
+            final Supplier<Ingredient> repairIngredient
+    ) {
+        this.incorrectBlocksForDrops = inverseTag;
+        this.uses = itemDurability;
+        this.speed = miningSpeed;
+        this.damage = attackDamage;
+        this.enchantmentValue = enchantability;
+        this.level = level;
+        this.repairIngredient = Suppliers.memoize(repairIngredient::get);
+    }
+
+    @Override
+    public int getUses() {
+        return this.uses;
+    }
+
+    @Override
+    public float getSpeed() {
+        return this.speed;
+    }
+
+    @Override
+    public float getAttackDamageBonus() {
+        return this.damage;
+    }
+
+    @Override
+    public TagKey<Block> getIncorrectBlocksForDrops() {
+        return this.incorrectBlocksForDrops;
+    }
+
+    @Override
+    public int getEnchantmentValue() {
+        return this.enchantmentValue;
+    }
+
+    @Override
+    public int getLevel() {
+        return this.level;
+    }
+
+    @Override
+    public Ingredient getRepairIngredient() {
+        return this.repairIngredient.get();
+    }
+}
diff --git a/src/main/java/net/minecraft/world/item/WeaponType.java b/src/main/java/net/minecraft/world/item/WeaponType.java
new file mode 100644
index 0000000000000000000000000000000000000000..b675ad0b1a17c2f417208e72f89522a0f3901c00
--- /dev/null
+++ b/src/main/java/net/minecraft/world/item/WeaponType.java
@@ -0,0 +1,145 @@
+package net.minecraft.world.item;
+
+import net.atlas.combatify.Combatify;
+import net.minecraft.network.RegistryFriendlyByteBuf;
+import net.minecraft.network.codec.StreamCodec;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.EquipmentSlotGroup;
+import net.minecraft.world.entity.ai.attributes.AttributeModifier;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.item.component.ItemAttributeModifiers;
+
+import static net.minecraft.world.item.Item.BASE_ATTACK_DAMAGE_ID;
+
+public class WeaponType {
+	public static final StreamCodec<RegistryFriendlyByteBuf, WeaponType> STREAM_CODEC = StreamCodec.of((buf, weaponType) -> buf.writeUtf(weaponType.name), buf -> WeaponType.fromID(buf.readUtf()));
+	public static final WeaponType EMPTY = createBasicUntierable("empty", 0, 0, 0);
+    public static final WeaponType SWORD = createBasic("sword", 2, 0.5, 0.5);
+	public static final WeaponType MACE = createBasic("mace", 2, -1.5, 0);
+	public static final WeaponType LONGSWORD = createWithHoeDamageFormula("longsword", 0, 0.5, 1);
+    public static final WeaponType AXE = createAxe("axe", 3, -0.5, 0);
+    public static final WeaponType PICKAXE = createBasic("pickaxe", 1, 0, 0);
+    public static final WeaponType HOE = createWithHoeDamageFormulaAndSpeed("hoe", 0, 1, 1);
+    public static final WeaponType SHOVEL = createBasic("shovel", 0, -0.5, 0);
+	public static final WeaponType KNIFE = createBasic("knife", 1, 1, 0.25);
+    public static final WeaponType TRIDENT = createWithAxeDamageFormula("trident", 3, -0.5, 1);
+	public final String name;
+	public final double damageOffset;
+	public final double speed;
+	public final double reach;
+	public final boolean useAxeDamage;
+	public final boolean useHoeDamage;
+	public final boolean useHoeSpeed;
+	public final boolean tierable;
+
+    public static final ResourceLocation BASE_ATTACK_SPEED_CTS_ID = ResourceLocation.withDefaultNamespace("base_attack_speed_cts");
+    public static final ResourceLocation BASE_ATTACK_REACH_ID = ResourceLocation.withDefaultNamespace("base_attack_reach");
+	public WeaponType(String name, double damageOffset, double speed, double reach, boolean useAxeDamage, boolean useHoeDamage, boolean useHoeSpeed, boolean tierable) {
+		this(name, damageOffset, speed, reach, useAxeDamage, useHoeDamage, useHoeSpeed, tierable, false);
+	}
+	public WeaponType(String name, double damageOffset, double speed, double reach, boolean useAxeDamage, boolean useHoeDamage, boolean useHoeSpeed, boolean tierable, boolean duringSync) {
+		this.name = name;
+		this.damageOffset = damageOffset;
+		this.speed = speed;
+		this.reach = reach;
+		this.useAxeDamage = useAxeDamage;
+		this.useHoeDamage = useHoeDamage;
+		this.useHoeSpeed = useHoeSpeed;
+		this.tierable = tierable;
+	}
+	public static WeaponType createBasic(String name, double damageOffset, double speed, double reach) {
+		return new WeaponType(name, damageOffset, speed, reach, false, false, false, true);
+	}
+	public static WeaponType createBasicUntierable(String name, double damageOffset, double speed, double reach) {
+		return new WeaponType(name, damageOffset, speed, reach, false, false, false, false);
+	}
+	public static WeaponType createWithAxeDamageFormula(String name, double damageOffset, double speed, double reach) {
+		return new WeaponType(name, damageOffset, speed, reach, true, false, false, true);
+	}
+	public static WeaponType createAxe(String name, double damageOffset, double speed, double reach) {
+		return new WeaponType(name, damageOffset, speed, reach, true, false, false, true);
+	}
+	public static WeaponType createWithHoeDamageFormula(String name, double damageOffset, double speed, double reach) {
+		return new WeaponType(name, damageOffset, speed, reach, false, true, false, true);
+	}
+	public static WeaponType createWithHoeDamageFormulaAndSpeed(String name, double damageOffset, double speed, double reach) {
+		return new WeaponType(name, damageOffset, speed, reach, false, true, true, true);
+	}
+
+    public void addCombatAttributes(Tier tier, ItemAttributeModifiers.Builder attributeModifiers) {
+		if (isEmpty())
+			return;
+        double speed = this.getSpeed(tier);
+        double damage = this.getDamage(tier);
+        double reach = this.getReach();
+        attributeModifiers.add(Attributes.ATTACK_DAMAGE, new AttributeModifier(BASE_ATTACK_DAMAGE_ID, damage, AttributeModifier.Operation.ADD_VALUE), EquipmentSlotGroup.MAINHAND);
+		attributeModifiers.add(Attributes.ATTACK_SPEED, new AttributeModifier(BASE_ATTACK_SPEED_CTS_ID, speed, AttributeModifier.Operation.ADD_VALUE), EquipmentSlotGroup.MAINHAND);
+        if (reach != 0.0F)
+            attributeModifiers.add(Attributes.ENTITY_INTERACTION_RANGE, new AttributeModifier(BASE_ATTACK_REACH_ID, reach, AttributeModifier.Operation.ADD_VALUE), EquipmentSlotGroup.MAINHAND);
+    }
+
+	public double getDamage(Tier tier) {
+		double damageBonus = tier.getAttackDamageBonus();
+		return damageFormula(damageBonus, tier);
+    }
+
+    public double getSpeed(Tier tier) {
+		return speedFormula(tier);
+    }
+
+    public double getReach() {
+		return reach;
+    }
+	public double getChargedReach() {
+		return 1.0;
+	}
+	public boolean canSweep() {
+		return false;
+	}
+	public boolean isEmpty() {
+		return this == EMPTY;
+	}
+	public static WeaponType fromID(String id) {
+		return Combatify.defaultWeaponTypes.get(id);
+	}
+	public double damageFormula(double damageBonus, Tier tier) {
+		if (!tierable)
+			return damageOffset;
+		else if (useAxeDamage) {
+			return damageBonus + 3.0;
+		} else if (useHoeDamage) {
+			if (tier != Tiers.IRON && tier != Tiers.DIAMOND && tier.getLevel() != 2 && tier.getLevel() != 3) {
+				if (tier == Tiers.NETHERITE || tier.getLevel() >= 4)
+					return tier == Tiers.NETHERITE ? 2 : 2 + damageBonus - 3;
+
+				return 0;
+			}
+			return 1;
+		}
+		return damageBonus + damageOffset;
+	}
+	public double speedFormula(Tier tier) {
+		if (useHoeSpeed) {
+			if (tier == Tiers.WOOD)
+				return -0.5;
+			else if (tier == Tiers.IRON)
+				return 0.5;
+			else if (tier == Tiers.DIAMOND || tier == Tiers.GOLD || tier == Tiers.NETHERITE || tier.getLevel() >= 4)
+				return 1.0;
+			else
+				return 0.0;
+		}
+		return speed;
+	}
+	public static void init() {
+		Combatify.defineDefaultWeaponType(SWORD);
+		Combatify.defineDefaultWeaponType(MACE);
+		Combatify.defineDefaultWeaponType(LONGSWORD);
+		Combatify.defineDefaultWeaponType(AXE);
+		Combatify.defineDefaultWeaponType(PICKAXE);
+		Combatify.defineDefaultWeaponType(HOE);
+		Combatify.defineDefaultWeaponType(SHOVEL);
+		Combatify.defineDefaultWeaponType(KNIFE);
+		Combatify.defineDefaultWeaponType(TRIDENT);
+	}
+}
